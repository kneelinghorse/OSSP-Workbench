# Mission B7.2.0: Agent Registration State Machine
*Week 7, Days 3-4 - State Machine Implementation*

## Mission Status
- **Phase**: Week 7 - Protocol Suite Enhancement
- **Mission ID**: B7.2.0
- **Status**: ACTIVE ðŸš€
- **Started**: 2025-10-06
- **Completed**: [TBD]
- **Target Completion**: 2 days
- **Dependencies**: B7.1.0 Complete âœ…, B7.1.1 Complete âœ…

---

## Mission Overview

Build a production-ready state machine for protocol manifest lifecycle management using hierarchical state machines (statecharts), file-based persistence with event sourcing, and optimistic concurrency control.

### Why This Matters
- **B7.2.1** (Registry Integration): Needs state machine for atomic catalog updates
- **B7.3.0** (Workflows): Requires state machine pattern for orchestration
- **Future**: Foundation for distributed agent registration and approval workflows

---

## Research Foundation

**Primary Research**: `missions/research/SPRINT_07_RESEARCH_R7.1.1.md`

### Key Findings Applied
1. **Hierarchical State Machines (Statecharts)**: XState-inspired pattern to avoid state explosion
2. **Event Sourcing**: Append-only event log for complete audit trail and recovery
3. **Optimistic Locking**: Version-based concurrency control for high-throughput, low-contention scenarios
4. **Saga Pattern**: Compensating transactions for multi-step rollback
5. **Actor Model**: Event-driven communication for decoupled orchestration

### Performance Targets
```yaml
state_transition: <10ms typical
file_persistence: <50ms (atomic write)
event_log_append: <5ms (with fsync)
optimistic_lock_retry: <3 attempts typical
recovery_from_events: <100ms for 100 events
```

---

## Technical Scope

### Core Deliverable
```javascript
// app/core/registration/registration-pipeline.js
class RegistrationPipeline {
  /**
   * State machine definition
   */
  stateMachine = {
    states: ['DRAFT', 'REVIEWED', 'APPROVED', 'REGISTERED'],
    transitions: {
      DRAFT: ['submit_for_review'],
      REVIEWED: ['approve', 'reject'],
      APPROVED: ['register', 'reject'],
      REGISTERED: []
    }
  }

  /**
   * Transition to a new state with validation
   * @param {string} manifestId - Unique manifest identifier
   * @param {string} targetState - Target state name
   * @param {Object} context - Additional context data
   * @returns {Promise<TransitionResult>}
   */
  async transitionState(manifestId, targetState, context) {}

  /**
   * Persist state to filesystem with optimistic locking
   * @param {string} manifestId
   * @param {Object} state
   * @returns {Promise<void>}
   */
  async persistState(manifestId, state) {}

  /**
   * Load state from filesystem with version check
   * @param {string} manifestId
   * @returns {Promise<StateSnapshot>}
   */
  async loadState(manifestId) {}

  /**
   * Emit lifecycle event for state change
   * @param {string} manifestId
   * @param {string} fromState
   * @param {string} toState
   * @param {Object} metadata
   */
  emitStateChange(manifestId, fromState, toState, metadata) {}

  /**
   * Recover state by replaying event log
   * @param {string} manifestId
   * @returns {Promise<StateSnapshot>}
   */
  async recoverFromEvents(manifestId) {}
}
```

### Out of Scope (Future Missions)
- Multi-user concurrent editing â†’ Future (requires distributed locking)
- State rollback beyond one step â†’ B7.3.0 (Workflows)
- External approval workflows (webhooks, integrations) â†’ Future
- XState library integration â†’ Simplified implementation first

---

## Implementation Plan

### Phase 1: State Machine Foundation (Part 1)
- [ ] Define state machine structure (states, transitions, guards)
- [ ] Implement state validation logic
- [ ] Create transition guard functions
- [ ] Implement basic state transition logic

**Files to Create:**
- `app/core/registration/registration-pipeline.js`
- `app/core/registration/state-machine-definition.js`

### Phase 2: File-Based Persistence (Part 2)
- [ ] Implement directory structure management
- [ ] Create atomic write with temp-file-and-rename pattern
- [ ] Implement state snapshot (state.json) persistence
- [ ] Create append-only event log (events.log)
- [ ] Add fsync for durability guarantees

**Files to Create:**
- `app/core/registration/file-persistence.js`
- `app/core/registration/atomic-writer.js`

### Phase 3: Optimistic Locking (Part 3)
- [ ] Add version field to state snapshots
- [ ] Implement compare-and-swap logic
- [ ] Create OptimisticLockException
- [ ] Add exponential backoff retry logic
- [ ] Implement conflict detection

**Files to Create:**
- `app/core/registration/optimistic-lock.js`
- `app/core/registration/retry-strategy.js`

### Phase 4: Event Sourcing & Recovery (Part 4)
- [ ] Define structured event format
- [ ] Implement event log writer (JSON Lines)
- [ ] Create event replay mechanism
- [ ] Add recovery from corrupted snapshot
- [ ] Implement deterministic state reconstruction

**Files to Create:**
- `app/core/registration/event-sourcing.js`
- `app/core/registration/event-replay.js`

### Phase 5: Event Emission (Part 5)
- [ ] Create EventEmitter for state transitions
- [ ] Define standard event structure
- [ ] Implement metadata enrichment
- [ ] Add event correlation IDs
- [ ] Create event subscription interface

**Files to Create:**
- `app/core/registration/event-emitter.js`
- `app/core/registration/event-schema.js`

### Phase 6: Testing & Integration (Part 6)
- [ ] Unit tests for state transitions
- [ ] Tests for optimistic locking
- [ ] Event sourcing recovery tests
- [ ] Concurrency stress tests
- [ ] Integration tests with fixtures

**Files to Create:**
- `app/tests/registration/registration-pipeline.test.js`
- `app/tests/registration/optimistic-lock.test.js`
- `app/tests/registration/event-sourcing.test.js`
- `app/tests/registration/concurrency.test.js`

---

## Success Criteria

### Functional Requirements
- âœ… State transitions enforced by state machine definition
- âœ… File-based persistence with atomic writes
- âœ… Optimistic locking prevents concurrent write conflicts
- âœ… Event log provides complete audit trail
- âœ… Recovery from event log works correctly
- âœ… Events emitted for all state transitions

### Performance Requirements
- âœ… State transition <10ms (excluding I/O)
- âœ… File persistence <50ms (atomic write)
- âœ… Event log append <5ms (with fsync)
- âœ… Optimistic lock retry succeeds within 3 attempts (95% of cases)
- âœ… Recovery from 100 events <100ms

### Test Coverage
- âœ… 90%+ code coverage
- âœ… All state transitions tested
- âœ… Concurrency edge cases covered
- âœ… Recovery scenarios validated

---

## Files to Create

```
app/core/registration/
â”œâ”€â”€ registration-pipeline.js          # Main state machine class
â”œâ”€â”€ state-machine-definition.js       # State definitions and transitions
â”œâ”€â”€ file-persistence.js               # File I/O with atomic writes
â”œâ”€â”€ atomic-writer.js                  # Temp-file-and-rename pattern
â”œâ”€â”€ optimistic-lock.js                # Version-based concurrency control
â”œâ”€â”€ retry-strategy.js                 # Exponential backoff retry
â”œâ”€â”€ event-sourcing.js                 # Event log management
â”œâ”€â”€ event-replay.js                   # Recovery from events
â”œâ”€â”€ event-emitter.js                  # EventEmitter for transitions
â”œâ”€â”€ event-schema.js                   # Event structure definitions
â””â”€â”€ index.js                          # Barrel exports

app/tests/registration/
â”œâ”€â”€ registration-pipeline.test.js     # Core state machine tests
â”œâ”€â”€ optimistic-lock.test.js           # Concurrency control tests
â”œâ”€â”€ event-sourcing.test.js            # Event log and recovery tests
â”œâ”€â”€ concurrency.test.js               # Stress tests for concurrent writes
â””â”€â”€ integration.test.js               # End-to-end integration tests

app/fixtures/registration/
â”œâ”€â”€ sample-manifest-draft.json        # Sample DRAFT state manifest
â”œâ”€â”€ sample-manifest-reviewed.json     # Sample REVIEWED state manifest
â””â”€â”€ sample-event-log.jsonl            # Sample event log for testing

app/examples/
â””â”€â”€ registration-demo.js              # Demo script showing lifecycle
```

---

## Integration Points

### With Week 7 Deliverables
- Uses parser from B7.1.0 for manifest validation before transitions
- Leverages error model from B7.1.1 for structured error reporting
- Emits progress events compatible with B7.1.1 progress tracker

### Enables Week 7 Missions
- **B7.2.1**: Registry integration uses state machine for orchestration
- **B7.3.0**: Workflow library patterns based on this state machine
- **B7.4.0**: Feedback system integrates with state transition events

---

## Context for AI Assistant

### What Already Exists
- âœ… Parser (B7.1.0, B7.1.1) for manifest validation
- âœ… Error model (B7.1.1) for structured error reporting
- âœ… Progress tracking (B7.1.1) for long-running operations
- âœ… Catalog index (B5.1) for URN storage (used in REGISTERED state)

### Key Patterns to Reuse
- Event Sourcing pattern from research
- Optimistic locking from Kubernetes pattern
- Atomic writes from file persistence research
- Saga pattern for multi-step rollback (deferred to B7.3.0)

### Dependencies
```json
{
  "write-file-atomic": "^5.0.1",
  "eventemitter3": "^5.0.1"
}
```

---

## Handoff Context for Next Mission

Upon completion, provide:

```json
{
  "completed": [
    "State machine with DRAFTâ†’REVIEWEDâ†’APPROVEDâ†’REGISTERED lifecycle",
    "File-based persistence with atomic writes",
    "Optimistic locking with version control",
    "Event sourcing with append-only log",
    "Event emission for all transitions",
    "Recovery from event log"
  ],
  "interfaces": [
    "RegistrationPipeline.transitionState(id, targetState, context)",
    "RegistrationPipeline.loadState(id)",
    "RegistrationPipeline.persistState(id, state)",
    "RegistrationPipeline.on('stateChange', handler)"
  ],
  "assumptions": [
    "Single-node deployment (no distributed locking)",
    "File-based persistence only (no database)",
    "Low-contention environment (optimistic locking sufficient)",
    "Events are idempotent and deterministic"
  ],
  "performance_achieved": {
    "state_transition": "actual ms",
    "file_persistence": "actual ms",
    "optimistic_lock_retries": "average attempts",
    "event_recovery": "actual ms for 100 events"
  },
  "next_mission": "B7.2.1 - Registry & Graph Integration",
  "blockers": []
}
```

---

## Notes

### Important Decisions Made
1. **File-based persistence**: Dual-file approach (snapshot + event log) for performance and durability
2. **Optimistic locking**: Chosen over pessimistic for low-contention environment
3. **Event sourcing**: Append-only log provides audit trail and recovery
4. **Simplified state machine**: Use plain JavaScript instead of XState for minimal dependencies
5. **Atomic writes**: Temp-file-and-rename pattern for crash safety

### Watch Out For
- Optimistic lock retries should use exponential backoff with jitter
- Event log must use fsync for durability guarantees
- State transitions must be idempotent for safe retries
- Version field must be incremented atomically
- Event replay must be deterministic

---

*Mission B7.2.0 Active*
*Previous: B7.1.1 Complete âœ…*
*Next: B7.2.1 - Registry & Graph Integration*
*Updated: October 6, 2025*
